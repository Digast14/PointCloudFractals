#version 450 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in; // Work group size


layout (std430, binding = 0) buffer Points {
    vec3 points[]; // Output vertices
};

layout (std430, binding = 1) buffer NormalBuffer {
    vec3 normals[]; // Output vertices
};
layout (std430, binding = 2) buffer GlobalIndex {
    uint globalIndex;
};

uniform int vertexArrayLength;
uniform int gridDensity;
uniform float range;


uniform float timeSin;
uniform int u_qZeroC;
uniform vec4 u_qZero;
uniform int u_maxIteration;
uniform float u_nudgeValue;
uniform float u_breakoutFactor;
uniform int u_reverse;
uniform float u_normalPrecision;
uniform float u_normalStepSize;
uniform int u_power;
uniform int u_pass;


int n = u_power;



//math function
vec4 qmul(in vec4 a, in vec4 b) {
    if (a.y == 0 && a.z == 0 && a.w == 0) return a.x * b;
    if (b.y == 0 && b.z == 0 && b.w == 0) return a * b.x;

    return vec4(
    a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,
    a.x * b.y + a.y * b.x + a.z * b.w - a.w * b.z,
    a.x * b.z - a.y * b.w + a.z * b.x + a.w * b.y,
    a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x
    );
}

vec4 qmul(in vec4 a, in float b) {
    return vec4(a.x * b, a.y * b, a.z * b, a.w * b);
}

vec4 qmul(in float b, in vec4 a) {
    return vec4(a.x * b, a.y * b, a.z * b, a.w * b);
}

vec4 qdiv(in vec4 a, in vec4 b) {
    float normSquared = dot(b, b);
    if (normSquared == 0.0) return vec4(0.0);

    vec4 bConjugate = vec4(b.x, -b.yzw);

    return vec4(
    (a.x * bConjugate.x - a.y * bConjugate.y - a.z * bConjugate.z - a.w * bConjugate.w) / normSquared,
    (a.x * bConjugate.y + a.y * bConjugate.x + a.z * bConjugate.w - a.w * bConjugate.z) / normSquared,
    (a.x * bConjugate.z - a.y * bConjugate.w + a.z * bConjugate.x + a.w * bConjugate.y) / normSquared,
    (a.x * bConjugate.w + a.y * bConjugate.z - a.z * bConjugate.y + a.w * bConjugate.x) / normSquared
    );
}

//expanded functions
vec4 qsin(vec4 q) {
    float a = q.x;
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(sin(a) * cosh(vabs), cos(a) * sinh((vabs)) * v / vabs);
}
vec4 qcos(vec4 q) {
    float a = q.x;
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(cos(a) * cosh(vabs), -sin(a) * sinh((vabs)) * v / vabs);
}
vec4 qexp(vec4 q) {
    if (dot(q, q) == 0) return vec4(0);
    float expA = exp(q.x);
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(expA * cos(vabs), expA * (v / vabs * sin(vabs)));
}
vec4 qln(vec4 q) {
    if (dot(q, q) == 0) return vec4(0);
    float qabs = length(q);
    float ln = log(qabs);
    float a = q.x;
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(ln, (v / vabs) * acos(a / qabs));
}
vec4 qpow(vec4 q, float n) {
    if (n.x == 2) return qmul(q, q);
    if (n.x == 3) return qmul(qmul(q, q), q);
    return qexp(n * qln(q));
}
vec4 qpow(vec4 q, vec4 n) {
    if (n.x == 2) return qmul(q, q);
    if (n.x == 3) return qmul(qmul(q, q), q);
    return qexp(n.x * qln(q));
}



//------------------------------------------------
// Function placeholder
vec4 javaFunction(vec4 q, vec4 c) {
    return /**/qsin(q);
}



int mode = 0;

int JuliaSet(in vec3 c) {
    vec4 z;
    vec4 zNudge;
    if (u_qZeroC == 0) {
        z = vec4(c, 0);
        zNudge = z + z * u_nudgeValue;
    } else {
        z = u_qZero;
        zNudge = u_qZero;
    }

    for (int iteration = 0; iteration < u_maxIteration; iteration++) {
        z = javaFunction(z, vec4(c, 0));
        zNudge = javaFunction(zNudge, vec4(c, 0) + vec4(c, 0) * u_nudgeValue);
        if (length(z - zNudge) > 1.0 && (iteration > u_maxIteration * u_breakoutFactor)) {
            if (mode == 0)return abs(u_reverse);
            return abs(u_reverse - 1);
        }
    }
    if (mode == 0) return abs(u_reverse - 1);
    return abs(u_reverse);


}

vec3 calculateNormal(in vec3 p)
{
    mode = 1;

    int gradient_x = 0;
    int gradient_y = 0;
    int gradient_z = 0;

    vec3 small_step = vec3(0);
    float relativeStepSize = u_normalStepSize * range;


    if (true) {
        for (int i = 0; i < u_normalPrecision; i++) {
            small_step += vec3(relativeStepSize, 0, 0); //*range
            gradient_x += JuliaSet(p + small_step.xyy) - JuliaSet(p - small_step.xyy);
            gradient_y += JuliaSet(p + small_step.yxy) - JuliaSet(p - small_step.yxy);
            gradient_z += JuliaSet(p + small_step.yyx) - JuliaSet(p - small_step.yyx);
        }
    } else {
        vec3 small_step = vec3(relativeStepSize, 0, 0); //*range

        for (int i = 1; i <= u_normalPrecision; i++) {
            int xResult = JuliaSet(p + vec3(relativeStepSize, 0, 0) * i);
            if (xResult == 0) break;
            gradient_x += xResult;

        }
        for (int i = 1; i <= u_normalPrecision; i++) {
            int xResultN = JuliaSet(p - vec3(relativeStepSize, 0, 0) * i);
            if (xResultN == 0) break;
            gradient_x -= xResultN;
        }


        for (int i = 1; i <= u_normalPrecision; i++) {
            int yResult = JuliaSet(p + small_step.yxy * i);
            if (yResult == 0) break;
            gradient_y += yResult;
        }
        for (int i = 1; i <= u_normalPrecision; i++) {
            int yResultN = JuliaSet(p - small_step.yxy * i);
            if (yResultN == 0) break;
            gradient_y -= yResultN;
        }


        for (int i = 1; i <= u_normalPrecision; i++) {
            int zResult = JuliaSet(p + small_step.yyx * i);
            if (zResult == 0) break;
            gradient_z += zResult;
        }
        for (int i = 1; i <= u_normalPrecision; i++) {
            int zResultN = JuliaSet(p - small_step.yyx * i);
            if (zResultN == 0) break;
            gradient_z -= zResultN;
        }
    }


    vec3 normal = vec3(gradient_x, gradient_y, gradient_z) / u_normalPrecision;
    if (dot(normal, normal) == 0) return vec3(0.1);
    else return normalize(normal);
}


void main() {
    ivec3 gridIndex = ivec3(gl_GlobalInvocationID);
    vec3 pos = (vec3(gridIndex) / float(gridDensity)) - vec3(range);

    if (JuliaSet(pos) > 0) {
        return;
    } else {
        uint currentIndex = atomicAdd(globalIndex, 1);
        if (u_pass == 1) {
            if (currentIndex < vertexArrayLength) {
                points[currentIndex + 1] = pos;
                normals[currentIndex + 1] = calculateNormal(pos);
            }
        }
    }
}
