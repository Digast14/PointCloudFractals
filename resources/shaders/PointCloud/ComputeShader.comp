#version 450 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in; // Work group size


layout (std430, binding = 0) buffer Points {
    vec3 points[]; // Output vertices
};

layout (std430, binding = 1) buffer NormalBuffer {
    vec3 normals[]; // Output vertices
};
layout (std430, binding = 2) buffer GlobalIndex {
    uint globalIndex;
};

uniform int vertexArrayLength;
uniform int gridDensity;
uniform float range;


uniform float timeSin;
uniform int u_qZeroC;
uniform vec4 u_qZero;
uniform int u_maxIteration;
uniform float u_nudgeValue;
uniform float u_breakoutFactor;
uniform int u_reverse;
uniform float u_normalPrecision;
uniform int u_power;
uniform int u_pass;


int n = u_power;



//math function
vec4 qmul(in vec4 a, in vec4 b) {
    if (a.y == 0 && a.z == 0 && a.w == 0) return a.x * b;
    if (b.y == 0 && b.z == 0 && b.w == 0) return a * b.x;

    return vec4(
    a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,
    a.x * b.y + a.y * b.x + a.z * b.w - a.w * b.z,
    a.x * b.z - a.y * b.w + a.z * b.x + a.w * b.y,
    a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x
    );
}

vec4 qmul(in vec4 a, in float b) {
    return vec4(a.x * b, a.y * b, a.z * b, a.w * b);
}

vec4 qmul(in float b, in vec4 a) {
    return vec4(a.x * b, a.y * b, a.z * b, a.w * b);
}

vec4 qdiv(in vec4 a, in vec4 b) {
    float normSquared = dot(b, b);
    if (normSquared == 0.0) return vec4(0.0);

    vec4 bConjugate = vec4(b.x, -b.yzw);

    return vec4(
    (a.x * bConjugate.x - a.y * bConjugate.y - a.z * bConjugate.z - a.w * bConjugate.w) / normSquared,
    (a.x * bConjugate.y + a.y * bConjugate.x + a.z * bConjugate.w - a.w * bConjugate.z) / normSquared,
    (a.x * bConjugate.z - a.y * bConjugate.w + a.z * bConjugate.x + a.w * bConjugate.y) / normSquared,
    (a.x * bConjugate.w + a.y * bConjugate.z - a.z * bConjugate.y + a.w * bConjugate.x) / normSquared
    );
}

//expanded functions
vec4 qsin(vec4 q) {
    float a = q.x;
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(sin(a) * cosh(vabs), cos(a) * sinh((vabs)) * v / vabs);
}
vec4 qcos(vec4 q) {
    float a = q.x;
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(cos(a) * cosh(vabs), -sin(a) * sinh((vabs)) * v / vabs);
}
vec4 qexp(vec4 q) {
    if (dot(q, q) == 0) return vec4(0);
    float expA = exp(q.x);
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(expA * cos(vabs), expA * (v / vabs * sin(vabs)));
}
vec4 qln(vec4 q) {
    if (dot(q, q) == 0) return vec4(0);
    float qabs = length(q);
    float ln = log(qabs);
    float a = q.x;
    vec3 v = vec3(q.yzw);
    float vabs = length(v);
    return vec4(ln, (v / vabs) * acos(a / qabs));
}
vec4 qpow(vec4 q, float n) {
    if (n.x == 2) return qmul(q, q);
    if (n.x == 3) return qmul(qmul(q, q), q);
    return qexp(n * qln(q));
}
vec4 qpow(vec4 q, vec4 n) {
    if (n.x == 2) return qmul(q, q);
    if (n.x == 3) return qmul(qmul(q, q), q);
    return qexp(n.x * qln(q));
}



//------------------------------------------------
// Function placeholder
vec4 javaFunction(vec4 q, vec4 c) {
    return /**/qsin(q);
}


float NewtonMethod(in vec3 c) {
    vec4 z;
    vec4 zNudge;
    if (u_qZeroC == 0) {
        z = vec4(c, 0);
        zNudge = z + z * u_nudgeValue;
    } else {
        z = u_qZero;
        zNudge = u_qZero;
    }

    for (int iteration = 0; iteration < u_maxIteration; iteration++) {
        z = javaFunction(z, vec4(c, 0));
        zNudge = javaFunction(zNudge, vec4(c, 0) + vec4(c, 0) * u_nudgeValue);
        if (length(z - zNudge) > 1.0 && (iteration > u_maxIteration * u_breakoutFactor)) {
            return abs(u_reverse);
        }
    }
    return abs(u_reverse - 1);
}


vec3 calculateNormal(in vec3 p)
{
    vec3 small_step = vec3(0.0);

    float stepSize = 0.0003;

    float gradient_x = 0;
    float gradient_y = 0;
    float gradient_z = 0;
    for (int i = 0; i < u_normalPrecision; i++) {
        small_step += vec3(stepSize, 0.0, 0.0) * range;
        gradient_x += NewtonMethod(p + small_step.xyy) - NewtonMethod(p - small_step.xyy);
        gradient_y += NewtonMethod(p + small_step.yxy) - NewtonMethod(p - small_step.yxy);
        gradient_z += NewtonMethod(p + small_step.yyx) - NewtonMethod(p - small_step.yyx);
    }
    vec3 normal = vec3(gradient_x / u_normalPrecision, gradient_y / u_normalPrecision, gradient_z / u_normalPrecision);

    if (dot(normal, normal) == 0) return vec3(0.1);
    else return normalize(normal);
}

void main() {
    ivec3 gridIndex = ivec3(gl_GlobalInvocationID);
    vec3 pos = (vec3(gridIndex) / float(gridDensity)) - vec3(range);

    if (NewtonMethod(pos) > 0) {
        return;
    } else {
        uint currentIndex = atomicAdd(globalIndex, 1);
        if(u_pass==1){
            if (currentIndex < vertexArrayLength) {
                points[currentIndex + 1] = pos;
                normals[currentIndex + 1] = calculateNormal(pos);
            }
        }
    }
}
